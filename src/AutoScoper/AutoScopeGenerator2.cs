// using System;
// using System.Collections.Generic;
// using System.Linq;
// using System.Text;
// using Microsoft.CodeAnalysis;
// using Microsoft.CodeAnalysis.CSharp.Syntax;
// using Microsoft.CodeAnalysis.Text;
//
// namespace AutoScoper;
//
// [Generator]
// public class AutoScopeGenerator: IIncrementalGenerator
// {
//     public void Initialize(IncrementalGeneratorInitializationContext context)
//     {
//         context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
//             AutoScopeAttributeHelper.GeneratedFileName,
//             SourceText.From(AutoScopeAttributeHelper.Attribute, Encoding.UTF8)));
//
//         var provider = context.SyntaxProvider
//             .ForAttributeWithMetadataName(
//                 AutoScopeAttributeHelper.FullName,
//                 predicate: static (node, _) => node is ClassDeclarationSyntax,
//                 transform: static (ctx, _) => CreateClassModel(ctx))
//             .Where(m => m != null);
//
//         context.RegisterSourceOutput(provider, static (context, classModel) =>
//         {
//             foreach (var interfaceModel in classModel.Interfaces)
//             {
//                 StringBuilder sourceBuilder = new(
//                     $$"""
//                     // <auto-generated/>
//                     namespace {{classModel.NameSpace}};
//
//                     public partial class {{classModel.Name}} : {{interfaceModel.FullyQualifiedName}}
//                     {
//
//                     """);
//
//                 foreach (var method in interfaceModel.Methods)
//                 {
//                     sourceBuilder.AppendLine(method);
//                 }
//
//                 sourceBuilder.AppendLine("}");
//
//                 //Concat class name and interface name to have unique file name if a class implements two interfaces with AutoImplement Attribute
//                 var generatedFileName = $"{classModel.Name}_{interfaceModel.FullyQualifiedName}.g.cs";
//                 context.AddSource(generatedFileName, sourceBuilder.ToString());
//             }
//         });
//     }
//
//     private static ClassModel CreateClassModel(GeneratorAttributeSyntaxContext ctx)
//     {
//         var classSymbol = ctx.TargetSymbol;
//
//         return new ClassModel(
//             classSymbol.Name,
//             classSymbol.ContainingNamespace.ToDisplayString(),
//             GetInterfaceModels(ctx.Attributes[0])
//         );
//     }
//
//     private static EquatableList<InterfaceModel> GetInterfaceModels(
//         AttributeData attribute)
//     {
//         EquatableList<InterfaceModel> result = [];
//
//         if (attribute.ConstructorArguments.Length == 0)
//             return result;
//
//         foreach(var constructorArgumentValue in attribute.ConstructorArguments[0].Values)
//         {
//             if (constructorArgumentValue.Value is not INamedTypeSymbol
//                 {
//                     TypeKind: TypeKind.Interface
//                 } interfaceSymbol)
//             {
//                 continue;
//             }
//
//             EquatableList<string> methods = new();
//
//             foreach (var interfaceMethod in interfaceSymbol
//                          .GetMembers()
//                          .OfType<IMethodSymbol>())
//             {
//                 var returnType = interfaceMethod.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
//
//                 var parameters = string.Join(
//                     ", ",
//                     interfaceMethod.Parameters.Select(x => $"{x.Type} {x.Name}"));
//
//                 methods.Add(
//                     $$"""
//                         public {{returnType}} {{interfaceMethod.Name}}({{parameters}})
//                             => throw new System.NotImplementedException();
//                     """);
//             }
//
//             result.Add(new InterfaceModel(interfaceSymbol.ToDisplayString(), methods));
//         }
//
//         return result;
//     }
// }
//
// #region Models
//
// internal record ClassModel(string Name, string NameSpace, EquatableList<InterfaceModel> Interfaces);
// internal record InterfaceModel(string FullyQualifiedName, EquatableList<string> Methods);
// internal class EquatableList<T> : List<T>, IEquatable<EquatableList<T>>
// {
//     public bool Equals(EquatableList<T>? other)
//     {
//         // If the other list is null or a different size, they're not equal
//         if (other is null || Count != other.Count)
//         {
//             return false;
//         }
//
//         // Compare each pair of elements for equality
//         for (var i = 0; i < Count; i++)
//         {
//             if (!EqualityComparer<T>.Default.Equals(this[i], other[i]))
//             {
//                 return false;
//             }
//         }
//
//         // If we got this far, the lists are equal
//         return true;
//     }
//     public override bool Equals(object obj)
//     {
//         return Equals(obj as EquatableList<T>);
//     }
//     public override int GetHashCode()
//     {
//         return this.Select(item => item?.GetHashCode() ?? 0).Aggregate((x, y) => x ^ y);
//     }
//     public static bool operator ==(EquatableList<T> list1, EquatableList<T> list2)
//     {
//         return ReferenceEquals(list1, list2)
//                || list1 is not null && list2 is not null && list1.Equals(list2);
//     }
//     public static bool operator !=(EquatableList<T> list1, EquatableList<T> list2)
//     {
//         return !(list1 == list2);
//     }
// }
//
// #endregion
